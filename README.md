# Лабораторные работы по ОПиПвСL

## Лабораторные работы по Организации процессов и программирования в среде Linux (ОПиПвСL), 7 семестр СПбГЭТУ "ЛЭТИ", 2022

### Лабораторная работа 4

Программу необходимо компилировать с флагом `-pthread`, который отвечает за мультипроцессорное программирование в используемой библиотеке `<pthread.h>`!

Например, `g++ -Wall -pthread -o "%e" "%f"`.

### Лабораторная работа 5

Программу необходимо запускать со следующими флагами:\
`./main (signal | sigaction | <other=default>) (1 | 2 | <other=default>)`, где:
- в части **./main**:
  - `./main` -- название программы (исполняемого файла);
- в части **(signal | sigaction | <other=default>)**:
  - `signal` -- использование функции `signal`;
  - `sigaction` -- использование функции `sigaction`;
  - `<other=default>` -- использование дефолтной функции (`signal`);
- в части **(1 | 2 | <other=default>)**:
  - `1` -- деление на 0 в качестве ошибки;
  - `2` -- обращение по **nullptr** адресу в качестве ошибки;
  - `<other=default>` -- дефолтная операция (деление на 0) в качестве ошибки.

Например, `./main signal 1` будет означать, что будет использоваться функция `signal` и что будет производиться деление на 0.

### Лабораторная работа 6

Компиляция программы стандартная.\
Запуск программы со следующими параметрами:

`./main <launch period> <number of launches>`, где:

- `<launch period>` — время периода между запусками программы в секундах (время между каждым запуском программы);
- `<number of launches>` — количество периодических запусков (сколько раз программа запустится).

### Лабораторная работа 7

#### Теория

В программе `main` на 80-й и 81-й строчках сигнал `SIGQUIT` отправляется в программы `executable_1` и `executable_2` для завершения этих программ.
Этот сигнал отправляется **после окончания записи в канал** программой `main`, чтобы уведомить программы `executable_1` и `executable_2`, что запись в канал закончена.
После получения уведомления об окончании записи в канал программами `executable_1` и `executable_2` **они смогут завершиться**, в **ином случае — не смогут**!
После получения сигнала `SIGQUIT` программами `executable_1` и `executable_2` запускается обработчик `LocalHandler` в них же, у которого (его код в конце программ `executable_1` и `executable_2`) просто изменяется переменная.
После того, как эта переменная изменилась, программы `executable_1` и `executable_2` **могут выйти из цикла и прекратить чтение** (например, строчка 41 в `executable_1`), до этого момента они **не могут выйти из цикла чтения, даже если канал был бы пустой**.

#### Запуск программы

Компиляция программы стандартная.\
Запуск программы со следующими параметрами:

`./main <filename.txt>`, где:

- `<filename.txt>` — имя читаемого программой файла в формате **txt**, например, `./main lorem_ipsum.txt`.

Внимание!
При создании файла важно учитывать формат окончания строки, на Unix/Linux это **LF — line feed** (`\n`),
а на Windows это **CRLF — carriage return line feed** (`\r\n`).
Из-за того, что файлы с разными форматами окончания строки будут читаться по-разному,
могут возникнуть ошибки, и программа может работать некорректно.
*Создавайте* файлы *на Linux* или *меняйте формат* окончания строки на *LF*!
Примеры в отчёте приведены для файлов с форматом окончания строки **LF**.

### Лабораторная работа 8

#### Теория

Зачем нужны функции `msgrcv` и `msgsnd`:

- `msgrcv` -- получить сообщение;
- `msgsnd` -- отправить сообщение.

Зачем нужны структуры `MessageRequest` и `MessageResponse`, а также их объекты в программе:

- `MessageRequest` — для посылки/принятия в общей очереди и для хранения всяких данных;
  - `MessageRequest message_request_receive[2]` — для хранения полученных запросов на чтение от других программ (то есть необработанных запросов), сделано 2 ячейки для двух других программ, от которых я принимаю запрос;
  - `MessageRequest message_request_send[4]` — для хранения отправленных запросов на чтение для других программ и для их отправки, сделано 4 ячейки для соответствия 1, 2 и 3 программ (одна из них не понадобится), а 0-я ячейка нужна для проверки завершения очереди;
  - `MessageRequest message_request` — для посылки запроса об окончании работы общей очереди;
- `MessageResponse` — для посылки/принятия в локальной очереди;
  - `MessageResponse message_response` — для отправки разрешения другим программам и для получения разрешения от других программ.

Пример 1:
```
msgsnd(message_request_receive[message_number].local_queue_id, &message_response, sizeof(message_response), 0)
```
В этой строке, оперирующей локальной очередью, есть `message_request_receive` типа `MessageRequest`,
но он служит для извлечения нужной нам локальной очереди
(чтобы разрешение отправить не в общую очередь, где все её могут прочитать, а в локальную, чтобы только эта программа могла её увидеть),
а `&message_response` типа `MessageResponse` служит уже для непосредственной отправки.

Пример 2:
```
msgrcv(common_queue, &message_request_receive[message_number], sizeof(message_request_receive[message_number]), program_id, IPC_NOWAIT) != -1
```
В этой строке, оперирующей общей очередью, идёт принятие из общей очереди,
и вторым параметром стоит уже `&message_request_receive[message_number]` типа `MessageRequest`.

Пример 3:
```
(msgrcv(local_queue, &message_response, sizeof(message_response), 0, IPC_NOWAIT) != -1)
```
В этой строке, оперирующей локальной очередью, `&message_response` типа `MessageResponse` служит для принятия, а не для отправки.

#### Director's cut (режиссёрская версия)

`Режиссёрская версия` — версия программы, созданная для работы,
которая содержит возможность менять значения `номера программы`, читаемого `файла` и `ключа` общей очереди и которая содержит ссылки и дополнительную информацию по коду и теме.

Компиляция программы стандартная.\
Запуск программы происходит в **трёх терминалах параллельно** со следующими параметрами:

`./main -num (1 | 2 | 3) -file <filename.txt> -key (<key_integer_number >= 0>)`, где:

- флаг `-num` — ID запускаемой программы, может быть только одним из следующих значений, при запуске трёх программ у каждой, очевидно, должны быть уникальные значения:
  - `1`;
  - `2`;
  - `3`;
- флаг `-file` — название читаемого программой файла в формате **txt**, расположенного в той же директории, что и исполняемый файл, например, `lorem_ipsum.txt`:
  - `<filename.txt>`;
- флаг `-key` — неотрицательный целочисленный ключ для создания общей очереди (в локальной очереди он всегда равен `IPC_PRIVATE = 0`), необходимый **для подключения к одной общей очереди другими программами** (очевидно, что все 3 запускаемые программы должны иметь **один и тот же ключ**):
  - `<key_integer_number > 0>` — положительный целочисленный ключ, программа будет работать корректно;
  - `<key_integer_number = 0>` — если вы выбираете ключ, равный `0 = IPC_PRIVATE`, то программа не будет работать, так как этот ключ создаёт приватную очередь, которую невозможно опознать другим программам.

Например, для **корректного запуска** трёх программ в **трёх терминалах параллельно** (каждую строку нужно запустить в отдельном терминале) значения будут следующими:

```
./main -num 1 -file lorem_ipsum.txt -key 190
./main -num 2 -file lorem_ipsum.txt -key 190
./main -num 3 -file lorem_ipsum.txt -key 190
```

#### Theatrical cut (театральная версия)

`Театральная версия` — версия программы, соданная для демонстрации,
которая уже содержит конкретные значения `номера программы`, читаемого `файла` и `ключа` общей очереди.

Компиляция программы стандартная.\
Запуск программ происходит в **трёх терминалах параллельно** без параметров:

`./executable_<id_number>`, где `<id_number>` равен `1`, `2` или `3`.

Значение ключа в этой версии для создания общей очереди равно `190`, ID в каждой из программ соответствующее, `1` для `./executable_1`, `2` для `./executable_2` и `3` для `./executable_3`, читаемый файл в каждой из программ `lorem_ipsum.txt`.

Например, для **корректного запуска** трёх программ в **трёх терминалах параллельно** (каждую строку нужно запустить в отдельном терминале) значения будут следующими:

```
./executable_1
./executable_2
./executable_3
```

### Лабораторная работа 9

#### Director's cut (режиссёрская версия)

Компиляция программы стандартная.\
Запуск программы происходит в трёх терминалах параллельно со следующими параметрами:

```
./main -id (0 | 1 | 2) -time interval_time -num number_of_strings -file *.txt -key shared_mem_seg_key_value
```

- `-id`
  - ID программы (процесса).
  - Может быть только 0, 1 или 2.
- `-time`
  - Время интервала между запусками для каждого цикла, то есть сколько времени мы будем ждать после начала новой итерации. Для функции `sleep(interval_time)`.
  - Целое число в диапазоне [-1; +inf].
- `-num`
  - Количество итераций, то есть сколько раз мы будем записывать строку в файл.
  - Целое число в диапазоне [0; +inf].
- `-file`
  - Название файла, в который 3 программы будут одновременно записывать свои строки, то есть за который будут конкурировать 3 процесса.
  - С разрешением `.txt`.
- `-key`
  - Ключ для создания/подключения сегмента разделяемой памяти.
  - Целое число в диапазоне [0; +inf]. Если `shared_mem_seg_key_value = 0 = IPC_PRIVATE`, программа, скорее всего, не будет работать нормально.

Например:

```
./main -id 0 -time 5 -num 5 -file shared_file.txt -key 190
./main -id 1 -time 2 -num 3 -file shared_file.txt -key 190
./main -id 2 -time 2 -num 5 -file shared_file.txt -key 190
```

Или, например, что использовалось для демонстрации:

```
./main -id 0 -time 3 -num 4 -file shared_file.txt -key 190
./main -id 1 -time 2 -num 4 -file shared_file.txt -key 190
./main -id 2 -time 2 -num 3 -file shared_file.txt -key 190
```

Ссылки, использованные для корректного написания документации для аргументов командной строки:

1. https://developers.google.com/style/code-syntax.
2. https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/command-line-syntax-key.
3. https://www.ibm.com/docs/en/iotdm/11.3?topic=interface-command-line-syntax.

#### Theatrical cut (театральная версия)

В отличие от режиссёрской версии, театральная программа подготовлена для демонстрации,
значение `номера (id)` программ равно `1`, `2` и `3` соответственно,
`имя файла` для одновременной записи строк 3-мя программами задано как `shared_file.txt`,
значение `ключа` для создания/подключения сегмента разделяемой памяти для всех равно `190`.

Программы запускаются (должны запускаться) параллельно, но в порядке согласно их номеру (id) в названии,
то есть при запуске в нескольких терминалах сначала должна запуститься программа
`executable_0`, затем `executable_1`, а в конце `executable_2`.
Нумерация программ начинается не с 1, а с 0.
Это связано с прямым соответствием номеров (id) программ,
указанных как в названии самой программы, так и самом коде,
с номерами ячеек массивов `bool choosing` и `int number`,
которые хранятся в разделяемой памяти и созданы для контроля доступа к общим ресурсам (к файлу).

Компиляция программы стандартная.\
Запуск программы происходит в трёх терминалах параллельно со следующими параметрами:

```
./executable_0 interval_time number_of_strings
./executable_1 interval_time number_of_strings
./executable_2 interval_time number_of_strings
```

- `-time`
  - Время интервала между запусками для каждого цикла, то есть сколько времени мы будем ждать после начала новой итерации. Для функции `sleep(interval_time)`.
  - Целое число в диапазоне [1; +inf].
- `-num`
  - Количество итераций, то есть сколько раз мы будем записывать строку в файл.
  - Целое число в диапазоне [1; +inf].

Например, что использовалось для демонстрации:

```
./executable_0 3 4
./executable_1 2 4
./executable_2 2 3
```

ВНИМАНИЕ: в `отчёте` и в программах `executable_0.cpp`, `executable_1.cpp` и `executable_0.cpp` в комментариях в коде
диапазон входных параметров `interval_time` и `number_of_strings` указан как
**[-1; +inf]** и **[0; +inf]** соответственно (как и у режиссёрской версии), что НЕВЕРНО.
Программы воспринимают диапазон только **[1; +inf]**, просто в коде остались старые комментарии.

### Лабораторная работа 10

#### Теория

Программы типа `writer` пишут строки в файл, программы типа `reader` их читают. Для удобства сделано так, что `writer`'ы выводят записанные в разделяемый файл строки в терминал и что `reader`'ы выводят считанные из разделяемого файла строки в терминал.

Все программы запускаются параллельно (последовательно в определённом порядке) в различных терминалах, не дожидаясь окончания работы остальных программ. Когда запускается программа `writer` и начинает писать в файл, параллельно и во время её работы нужно запускать программы `reader`, чтобы они читали этот файл (можно и до запуска `writer`, и после запуска, но тогда реальной работы семафоров не будет, а здесь именно это главное). Программа `reader` прочитает столько строк, сколько уже записано на момент получения ей возможности читать файл.

Программа `reader` будет читать всегда одна, если программы-писатели готовы, но она будет читать параллельно с другими программами-читателями, если программ-писателей нет или если никто из них не готов к записи. Иными словами, если есть готовый `writer` (готовые `writer`'ы) с запросом на запись (но ещё не записывающий), то читать может только один `reader`, а если нет готового `writer`'а (готовых `writer`'ов) с запросом на запись, то читать файл могут все `reader`'ы.

Также каждый раз нужно (желательно) удалять файл `shared_file.txt`, так как каждый раз программы будут записывать в него, не удаляя старые записи, что в итоге приведёт к его разрастанию.

Удаление семафора происходит последней оставшейся (активной) программой, а не той, которая его создала, чтобы если создавшая его программа закончит свою работу раньше всех, она не ждала завершения всех остальных программ. В программах ключ семафора всегда один, поэтому это сделать не так сложно. Для того, чтобы отслеживать количество оставшихся (активных) программ, изначально была создана переменная-счётчик в разделяемой памяти, которая впоследствие была заменена на 4-й семафор в наборе.

Программа-писатель `writer` запускается с параметрами **количества строк, записываемых в файл**, и **времени ожидания (перед переходом на следующую итерацию)** после завершения очередной итерации цикла. Программа-читатель `reader` запускается без параметров.

#### Запуск программы

Компиляция программы стандартная.\
Запуск программ происходит (может происходить) параллельно в нескольких терминалах со следующими параметрами:

```
./reader
```

```
./writer number_of_strings interval_time
```

- `number_of_strings`
  - Количество итераций (циклов), то есть сколько раз эта (ПИСАТЕЛЬ) программа (этот процесс) запишет строк в файл.
  - Целое число в диапазоне [0; +inf].
- `interval_time`
  - Период запуска программы (как аргумент для функции `sleep()`) для каждой итерации (каждого цикла), то есть какое время мы будем ждать после каждой итерации.
  - Целое число в диапазоне [-1; +inf].

#### Пример 1

Например, [в разных терминалах] запустить параллельно две программы-писателя:

```
./writer 5 4
./writer 10 2
```

Затем [в другом терминале] запустить одну программу-читатель:

```
./reader
```

А после записи пары строк программами-писателями снова запустить ещё две программы-читателей [в разных терминалах] (одна из них, запущенная позже, будет ждать возможности читать, так как есть готовые к записи программы-писатели):

```
./reader
./reader
```

После завершения работы программ-писателей можно также запустить ещё две программы-читателей [в разных терминалах] (они будут обе работать, читать, параллельно, так как нет активных программ-писателей):

```
./reader
./reader
```

#### Пример 2

```
./writer 6 1
./writer 7 1
./reader
./writer 5 1
./reader
```

#### Пример 3 (в отчёте и при демонстрации)

```
./writer 6 1
./reader
./writer 7 1
./reader
```

#### Если программа работает некорректно

При завершении программы с помощью `^C` (`Ctrl+C`) значения семафоров не изменяются корректно, что приводит к невозможности удалить семафор и к невозможности вновь получить доступ к файлу при следующем запуске программы.

Если в таком случае программа работает некорректно, то воспользуйтесь следующей [командой](https://www.unix.com/aix/74632-how-clean-unused-semaphore.html) в терминале Linux, которая удаляет семафор с определённым ID:

```
ipcrm -s <semaphore id>
```

ВАЖНО: ID — это не ключ, это число, возвращаемое при создании/открытии семафора в программе, которое в моей программе выводится в терминал!

### Лабораторная работа 11

#### Запуск программы

Компиляция программы стандартная.\
Запуск программ происходит (может происходить) параллельно в нескольких терминалах следующими командами:

```
./server
```

```
./client
```

Программа-сервер может быть запущена только одна, иначе будет ошибка `Address already in use`.
Программа-сервер `server` запускается с помощью команды `./server` без параметров.

Программ-клиентов может быть запущено несколько.
Программа-клиент `client` запускается с помощью команды `./client` без параметров.

Программа-подсервер `subserver` не запускается пользователем, она предназначена для запуска программой-сервером `server`.

#### Пример 1

Необходимо запустить [в ТРЁХ разных терминалах] в течение 15-ти секунд (такое ограничение установлено в программах на ожидание) сначала сервер, затем два клиента:

```
./server
./client
./client
```

#### Пример 2 (некорректный запуск)

Если запустить только ОДНУ программу (программу-сервер `server` или программу-клиент `client`), не запуская при этом ничего больше, то по истечение 15-ти секунд программа завершится из-за истечения времени ожидания.

```
./server
```

или

```
./client
```

#### Пример 3 (некорректный запуск)

Если запустить две программы-сервера `server` [в двух разных терминалах] в течение 15-ти секунд, то во второй (последней запущенной) программе-сервере `server` будет ошибка привязки к сетевому адресу `Address already in use`.

```
./server
./server
```

## Дополнительная информация

### Используемый на Linux компилятор

```
matmanbj@matmanbj-VirtualBox:~$ gcc --version
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

```
matmanbj@matmanbj-VirtualBox:~$ g++ --version
g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

### Версия Linux в файле `/etc/os-release`

```
matmanbj@matmanbj-VirtualBox:~$ cat /etc/os-release
NAME="Ubuntu"
VERSION="20.04.5 LTS (Focal Fossa)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 20.04.5 LTS"
VERSION_ID="20.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=focal
UBUNTU_CODENAME=focal
```

Взято [отсюда](https://www.cyberciti.biz/faq/how-to-check-os-version-in-linux-command-line/).

### Использование команды `lsb_release`

```
matmanbj@matmanbj-VirtualBox:~$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 20.04.5 LTS
Release:	20.04
Codename:	focal
```

Взято [отсюда](https://www.cyberciti.biz/faq/how-to-check-os-version-in-linux-command-line/).

### Использование команды `hostnamectl`

```
matmanbj@matmanbj-VirtualBox:~$ hostnamectl
   Static hostname: matmanbj-VirtualBox
         Icon name: computer-vm
           Chassis: vm
        Machine ID: e5c748f0a6434a2489252bb8c130fcbf
           Boot ID: 189c7cbf53c343488f885a2dc9e7a427
    Virtualization: oracle
  Operating System: Ubuntu 20.04.5 LTS
            Kernel: Linux 5.15.0-50-generic
      Architecture: x86-64
```

Взято [отсюда](https://www.cyberciti.biz/faq/how-to-check-os-version-in-linux-command-line/).

### Использование команды `uname` с флагом `-r`

```
matmanbj@matmanbj-VirtualBox:~$ uname -r
5.15.0-50-generic
```

Взято [отсюда](https://www.cyberciti.biz/faq/how-to-check-os-version-in-linux-command-line/).

# Лицензия

Этот проект находится под лицензией MIT. Дополнительная информация в файле `license.txt`.