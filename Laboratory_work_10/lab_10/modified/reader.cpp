// ./reader

#include <iostream>
#include <fstream>
#include <string>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sem_func.h" // файл с функциями с семафорами

using namespace std;

int main ()
{
	int sem_id; // ID семафора, возвращаемый при создании/открытии
	char file_buf[80]; // буфер для чтения файла
	ifstream file; // файл для чтения
	
	cout << "Процесс id=" << getpid() << "\n" << "Имя файла " << file_name << "\n" << "Ключ семафора " << sem_key << "\n";
	
	// semget(ключ семафора, количество семафоров в наборе (4 штуки), флаги для создания семафора и с правом доступа у всех)
	sem_id = semget(sem_key, 4, IPC_CREAT | IPC_EXCL | 0666); // создаём множественный семафор
	
	if (sem_id != -1)
	{
		cout << "Семафор id=" << sem_id << " создан процессом id=" << getpid() << "\n";
		// важный шаг: при создании семафора увеличиваем семафор файла на 1 (то есть максимум -- это 1)
		// этот семафор нужен только для писателей, он нужен для того,
		// чтобы отслеживать возможность записи в файл для писателей
		// при входе в цикл делаем -1, и он =0, поэтому остальные не могут сделать -1
		// так как не стоит флага IPC_NOWAIT, который сразу возвращает ошибку,
		// и остальные программы вынуждены ждать, пока семафор будет =1,
		// чтобы снова сделать -1 (пока =0 они ждут, так как <0 быть не может)
		semop(sem_id, &sem_file_in, 1);
	}	
	else
	{
		sem_id = semget(sem_key, 4, IPC_CREAT); // открываем семафор
		if (sem_id != -1)
		{
			cout << "Семафор id=" << sem_id << " открыт процессом id=" << getpid() << "\n";
		}
		else
		{
			cout << "Семафор не был открыт процессом id=" << getpid() << "\n";
			exit(-1);
		}
	}
	
	// увеличиваем количество активных процессов, чтобы в конце удаляла последняя программа
	semop(sem_id, &sem_proc_in, 1);
	
	cout << "Текущее количество работающих программ " << semctl(sem_id, 3, GETVAL, 0) << "\n\n";
	
	// начинаем чтение из файла
	
	cout << "Ждём окончания всех активных writer'ов в семафоре процессом id=" << getpid() << "\n";
	semop(sem_id, &sem_writer_com, 1);
	
	cout << "Увеличиваем число активных reader'ов в семафоре процессом id=" << getpid() << "\n";
	semop(sem_id, &sem_reader_in, 1);
	
	// здесь мы ждём только писателей, но не отслеживаем других читателей
	// (как это было сделано у писателей с семафором, у которого при создании выставляется 1),
	// потому что чтение этого не требует (в отличие от записи)
	// из-за этого и получается ситуация, когда при отсутствии писателей читают все,
	// а при наличии писателей в числе готовых, читает только один, так как идёт очередь из процессов,
	// и следующим (скорее всего) будет не читатель, а писатель
	
	cout << "Открываем файл на чтение \"" << file_name << "\" процессом id=" << getpid() << "\n";
	file.open(file_name);
	
	cout << "Читаем строки процессом id=" << getpid() << "\n";
	while (file.getline(file_buf, 80))
	{
		cout << file_buf << "\n";
		sleep(1);
	}
	
	cout << "Закрываем файл на чтение \"" << file_name << "\" процессом id=" << getpid() << "\n";
	file.close();
	
	cout << "Уменьшаем число активных reader'ов в семафоре процессом id=" << getpid() << "\n\n";
	semop(sem_id, &sem_reader_dec, 1);
	
	// уменьшаю количество активных процессов в семафоре на 1
	// в итоге у самой последней программы после этого шага будет 0, и она всё удалит
	semop(sem_id, &sem_proc_dec, 1);
	
	// сравниваю количество процессов (если=0, то значит захожу, если нет, то пропускаю)
	if (semctl(sem_id, 3, GETVAL, 0) == 0)
	{
		semctl(sem_id, IPC_RMID, 0); // удаляю семафор последней программой (последний процесс удаляет все 4 семафора)
		cout << "Семафор id=" << sem_id << " удалён\n\n";
	}
	
	return 0;
}
